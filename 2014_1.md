### 2014_1A_3 proper shuffle  
一个大小为 N 的排列, 是一个 N 个数字的序列, 从 0 到 N-1, 各出现一次.  
大小为 N 的排列有很多个. 有时候我们只想随机挑选一个.  
当然, 我们希望每个排列被选中的概率为 1/N.  
比如以下算法就是一个好的算法:  
```text  
for k in 0 .. N-1:  
  a[k] = k  
for k in 0 .. N-1:  
  p = randint(k .. N-1)  
  swap(a[k], a[p])  
```  
按照以上算法, 一个可能的过程如下:  
0 1 2 3 -> 2 1 0 3 -> 2 0 1 3 -> 2 0 3 1.  
同时, 有很多其他算法, 属于不好的算法, 每个排列被选中的概率不为 1/N.  
比如稍稍改动以上算法:  
```text  
for k in 0 .. N-1:  
  a[k] = k  
for k in 0 .. N-1:  
  p = randint(0 .. N-1)  
  swap(a[k], a[p])  
```  
在每一个测试案例中, 我们给出一个序列, 这个序列是这么产生的:  
以各 50% 的概率选择好算法和坏算法, 使用选中的算法产生一个序列.  
你能猜出这个序列是哪个算法产生的吗?  

#### 2014_1A_3 思路  
这个问题比较特殊, 因为不要求完全正确, 事实上, 最好的解决方法也可能出错.  
还是有一个方法, 用两个算法各随机产生足够多的排列, 看某种排列的出现次数.  
那么, 为什么好的排列算法是好的呢?  
如果一个算法是好的算法, 那么每个数字最终落在某个位置的概率都是 1/N.  
在好的算法里, 某个数被选择为第一位的概率是 1/N, 然后第一位不再变动.  
选择第二位时, 某个数被选择为第二位的概率是 (N-1)/N * 1/(N-1).  
以此类推, 某个数被选择到每一位的概率都是 1/N.  
那么, 为什么坏的排列算法是坏的呢?  
想象我们现在在第 i 步, 随机选择一个位置 j 上的数字 X, j 刚好比 i 小.  
那么在接下来的步骤中, X 只能被交换到比 i 更高的位置上.  
我们检查一下数字 i 最终落到位置 j 的概率.  
分布图显示, 坏的算法倾向于把小的数字分配到更高的位置.  
所以我们得出一个可能的区分法: 记录数字落在比自己高的位置的次数.  
```text  
def f(S):  
  score = 0  
  for i in 0 .. N-1:  
    if S[i] <= i:  
      score++  
  return score  
```  
对 N=1000, 我们进行了 10K 次独立试验画出分布图, 结果发现,  
好算法偏移量分布更接近 500, 坏算法偏移量分布更接近 472.  
接下来我们只要判断 score 是更接近 500 还是更接近 472 就行了.  

方法二:  
记 S 为要判断的排列, 我们想知道 P(GOOD|S), 目标排列由好算法产生的概率.  
由贝叶斯定理, P(GOOD|S) =  
P(S|GOOD) * P(GOOD) / (P(S|GOOD) * P(GOOD) + P(S|BAD) * P(BAD)).  
好算法产生 S 的概率 * 使用好算法的概率 / 产生 S 的概率.  
我们知道 P(GOOD) 和 P(BAD) 都是 1/2, 所以以上公式可以简化成:  
P(GOOD|S) = P(S|GOOD) / (P(S|GOOD) + P(S|BAD).  
如果 P(GOOD|S) > 0.5, 则更可能由好算法产生, 否则更可能由坏算法产生.  
我们知道 P(S|GOOD) = 1/N! 因为好算法能产生的序列有 N! 个.  
现在的问题是 P(S|BAD) 要怎么计算.  
我们可以借鉴一下机器学习的方法, 构造一个朴素贝叶斯分类器.  
假设每个元素的移动都是独立的, 那么,  
P(S|BAD) ≈  P(S[0]|BAD) * P(S[1]|BAD) * ... * P(S[N-1]|BAD)  
其中, P(S[0]|BAD) 的意思是, 用坏算法, 最终第 0 位的数字是 S[0] 的概率.  
现在我们看一下如何使用朴素贝叶斯分类器.  
记 `Pk[i][j]` 为 k 步之后, 数字 i 落到位置 j 的概率.  
我们感兴趣的是 `PN[i][j]`, 即进行 N 步之后, 数字 i 落到位置 j 的概率.  
我们可以动态规划计算最终的概率.  
```text  
prev[i][i] = 1.0 for all i, otherwise 0.0  // An identity matrix.  
pmove = 1.0 / N      // Probability of a number being swapped.  
pstay = 1.0 - pmove  // Probability of a number not being swapped.  

for k in 0 .. N-1:  
  for i in 0 .. N-1:  
      next[i][k] = 0  
      for j in 0 .. N-1:  
          next[i][k] += prev[i][j] * pmove       // i -> j -> k  
          if j != k:  
              next[i][j] = prev[i][j] * pstay +  // i -> j  
                           prev[i][k] * pmove    // i -> k -> j  
  Copy next to prev  
```  
其中 k 是最终位置, i 是数字, j 是 i 可能被置换到的中间位置.  
带入公式判断 P(S|GOOD) 是否 > 0.5 即可.  

  
### 2014_1A_2 full binary tree  
树是没有环的连通图.  
有根树是一棵树, 其中一个节点被称为根, 如果节点 X 比 Y 离根近,  
如果有从 X 到 Y 的边, 称 Y 为 X 的孩子.  
满二叉树是一棵有根树, 其中所有的节点要么有 2 个孩子, 要么没有孩子.  
给你有 N 个节点的树 G. 你可以删掉某些节点, 让剩下的节点组成满二叉树.  
你至少需要删掉多少节点?  

#### 2014_1A_2 思路  
小数据集: 暴力法  
N 个结点有 2^N 个集合, 枚举集合, 查看他们是不是满二叉树,  
最后选择满二叉树中剩下结点最多的那个.  

大数据集:  
方法一:  
首先, 尽量减少删除的结点, 也就是保留尽可能多的结点.  
我们为树选择一个根结点, 结点之间的父子关系也随之确定.  
每个结点的去留取决于以它为父结点的满二叉树的结点数量.  
我们可以后序 DFS 遍历来计算每个结点的子树结点数量.  
定义 maxSubtreeNodes(node, parent) 如下:  
1. 参数 node 为当前结点, parent 为它的父结点, 没有父结点则为 0.  
2. 如果当前结点只有 0 或 1 个子结点, 则返回 1.  
3. 否则, 返回结点最多的 2 个子树的结点之和 + 1.  
以 root 为根结点的树要删除的结点数为 N - maxSubtreeNodes(root, 0).  

方法二:  
在方法一中, 我们用了 O(N) 时间来计算任何根结点的 2 棵最大子树.  
所以我们的目标是, 用常数时间来计算任意结点的 2 棵最大子树大小.  
我们事先计算好任意结点的 3 棵最大子树的大小.  
线性解法的关键在于, 对指定根结点的树进行一次 DFS 遍历,  
就记录下所有结点的父结点, 最大的 3 棵子树及其大小.  
接下来我们想办法不尝试所有结点为根结点.  
在方法一中, 父结点并不作为最大子树的候选. 现在我们要把父结点纳入候选.  
从父结点的 3 棵最大子树中, 减去本结点的子树, 选择最大两棵子树加入候选.  
纳入候选的过程使用前序遍历 DFS.  
注意更新后的子树可能只有一个孩子, 这时候父亲子树的大小是 1.  
最后检查所有结点, 选择最大两棵子树结点之和最大的那个.  

  
### 2014_1A_1 charging chaos  
农民 Shota 遇到一个问题. 他刚刚搬进新的农庄, 但是充电插头没有弄对.  
他有 N 个电子设备, 每个设备需要不同的电流. 每个插头也产生不同的电流.  
电流可以表示为一串由 0 和 1 组成的, 长度为 L 的字符串.  
Shota 想让 N 个设备能够同时充电, 农庄里有 N 个插头.  
有一个含 L 个开关的总控面板, 第 i 个开关控制翻转所有插头的第 i 位电流.  
问是否有可能只靠总控面板的开关就让所有 N 个设备能正常充电.  
如果有可能, 至少需要翻转多少位开关?  

#### 2014_1A_1 思路  
小数据集: 暴力法  
枚举每一位翻转和不翻转的结果, 如果和设备匹配, 记录下翻转的位数.  

大数据集:  
首先, 可行的翻转序列是很少的, 如果我们只枚举可行的翻转, 计算量会小很多.  
其次, 设备有 N 个, 插头有 N 个, 设备和插头的配对只有 N^2 组,  
所以可能的可行翻转序列最多只有 N^2 个.  
最后, 因为一个设备最终一定要匹配一个插头,  
所以只要尝试匹配一个设备到所有插头, 就一定能试出最佳结果.  

  
### 2014_1B_3 the bored traveling salesman  
你的老板打算派你去环球推销.  
你有 N 个城市要去, 城市之间有双向航班.  
每个城市至少需要访问一次. 你可以预定任意数量的机票, 满足以下条件:  
1. 每张票包含 2 次飞行, 去程和回程.  
2. 你必须先用掉去程机票, 再用回程机票.  
3. 每个城市最多只能有 1 张去程机票到达, 回程机票不限.  
4. 你必须用掉所有预定的机票.  
5. 你可以从任意城市出发, 即不需要预定飞往那个城市的去程机票.  
现在你可以最小化旅行距离了. 但这次你想换个思路.  
你注意到, 每个城市有一组 5 位数的邮政编码.  
当你第一次到达某个城市的时候, 记录下它的邮政编码, 最后将它们串联起来.  
你能得到的最小号码是什么?  

#### 2014_1B_3 思路  
可以用图的问题建模. 城市是节点, 双向机票是边. 问题类似 DFS.  

小数据集:  
最多只有 8 个城市. 可以暴力法 DFS 解决.  

大数据集: 贪心法  
可以先按照邮政编码给每个城市排序.  
出发城市一定是邮政编码最小的. 接下来每次都访问最小相邻未访问节点.  
定义如下变量:  
DEAD: 已经访问并离开的节点集合;  
ACTIVE: 当前路径的栈;  
HEAD: 当前节点, 即当前路径栈的 top 节点;  
在每一步, 我们可以做如下操作中的其中一种:  
1. 访问 HEAD 节点的相邻最小未访问节点;  
2. 离开 HEAD 节点;  
现在的问题是, 如何确定应该选择哪个操作?  
我们可以随机选择一个和当前栈相连的节点吗? 显然不行, 看以下 3 种情况:  
1. Z < X < Y, 但是先访问 Z 会导致 X 无法访问; (参考配图)  
2. X < Y < Z, 先访问 X, 再回溯去访问 Y 和 Z;  
3. Y < X < Z, 回溯访问 Y, 回溯访问 X, 回溯访问 Z;  
也就是说, 在以上这个图中, Z 不是可行的 next 节点.  
所以当前状态下, 某个节点是不是可行 next, 在于是否会有未访问节点无法访问.  
可以使用 BFS 或者 DFS 进行连接性检查.  
所以找到 next 节点的大致解题过程如下:  
1. 检查当前 HEAD 节点的相邻最小未访问节点;  
2. 试着离开当前 HEAD 节点,  
   如果不行(会导致有节点无法访问), 返回检查的节点中邮政编码最小的.  
   如果可以, 往前回溯执行第一步, 直到回到出发节点.  

  
### 2014_1B_2 the lottery game  
彩票号码产生方法变了!  
以前用一台机器生成随机中奖号码, 但由于作弊问题, 彩票公司决定加一台.  
中奖号码将是两台机器生成号码的按位与的结果.  
不幸的是, 一名彩票公司的员工泄漏了一个消息:  
旧机器只会产生小于 A 的非负整数, 新机器只会产生小于 B 的非负整数.  
Catalina 想赢得彩票, 他打算买下小于 K 的所有非负整数.  
给你 A, B, K, 有多少种可能的机器结果组合可能让他赢得彩票呢?  

#### 2014_1B_2 思路  
记可行组合为 S(A, B, K), 可行组合的数量为 f(A, B, K).  

小数据集:  
暴力法枚举所有的 a 和 b, 看他们按位与之后是否小于 K.  

大数据集:  
方法一: 动态规划  
解决问题之前, 我们先看另一个问题: 对正整数 M, 有几个小于它的非负整数.  
自然结果是 M. 但我们现在要找到一个动态规划的方法.  
比如说 M = 29, 二进制是 11101. 记最后一位为第 0 位, 第 i 位为 mi.  
比如说我们已经产生了 m4 = 1, m3 = 0, 要考虑 m2 的取值.  
我们将现在的状态记为 10cyy, 前缀是 10, 当前位是 c, 之后要确定的位是 y.  
我们可以根据以下规则来确定 c.  
1. 0 总是可行的;  
2. 如果满足以下两个条件中的一个, 1 也是可行的:  
   2a: 当前状态的前缀小于 M 的前缀  
   2b: M 的第 i 位是 1.  
现在我们可以定义一个递归函数 count(i, lessM, M) 计算小于 M 的整数.  
其中 i 表示第几位. lessM 是布尔值, 表示前缀是否小于 M 的前缀.  
比如计算所有小于 29 的非负整数, 即 count(4, false, 29).  
```text  
res = count(i - 1, lessM || getBit(M, i) == 1, M); // 第 i 位为 0  
if (lessM || getBit(M, i) == 1) res += count(i - 1, lessM, M) // 为 1  
return res;  
```  
现在我们可以开始解决问题了, 我们可以枚举 a 和 b 的每一位, 再按位与.  
定义 countPairs(i, lessA, lessB, lessK, A, B, K):  
```text  
  if i == -1:  # The base case.  
    return lessA and lessB and lessK  # Count strictly less  

  maxA = lessA or getBit(A, i) == 1  
  maxB = lessB or getBit(B, i) == 1  
  maxK = lessK or getBit(K, i) == 1  

  # 0 & 0 = 0  
  count = countPairs(i - 1, maxA, maxB, maxK, A, B, K)  

  if maxA:  # 1 & 0 = 0  
    count += countPairs(i - 1, lessA, maxB, maxK, A, B, K)  

  if maxB:  # 0 & 1 = 0  
    count += countPairs(i - 1, maxA, lessB, maxK, A, B, K)  

  if maxA and maxB and maxK:  # 1 & 1 = 1  
    count += countPairs(i - 1, lessA, lessB, lessK, A, B, K)  

  return count  
```  

  
### 2014_1B_1 the repeater  
Fegla 和 Omar 喜欢玩游戏. 他们发明了一种新游戏, The Repeater.  
游戏有 2 个玩家. Fegla 写下 N 个字符串, Omar 的任务是让所有字符串相同.  
他可以采取以下几个动作:  
1. 选择任意字符串中的任意字母, 重复它. abc->abbc.  
2. 选择任意两个相邻的重复字母, 减去一个. abbc->abc.  
Omar 有没有办法完成任务? 如果能, 最少需要采取多少步?  

#### 2014_1B_1 思路  
问题的关键是, 每个字母应该重复多少次.  
暴力法: 从最小到最大, 一个一个试过去.  
更有效的方法:  
你可能会认为平均数是最终结果, 不是的. 我们来看一个例子:  
{1, 1, 100}, 平均数是 34, 需要 33 + 33 + 66 = 132 步.  
但是 30 的结果只需要 128 步.  
事实上, 在我们试过所有结果之后发现, 中位数才是正确的最终结果.  
证明如下:  
想象你站在一条笔直的路上, 路边种着一排树, 你想尽量减少你和树距离之和.  
比如树有 5 棵, 当你站在中间那棵树的时候,  
比如你往左移动了 1, 你向左边 2 棵树靠近了 1, 从右边 3 棵树离开了 1,  
总数增加了. 往相反方向移动也是一样的, 结果都只会增加. 所以最好不要动.  

  
### 2014_1C_3 enclosure  
在一个 N x M 的网格上, 要包围住至少 K 个交叉点, 至少需要放多少个石子?  
一个点被包围的意思是:  
1. 这个点上有石块  
2. 从这个点出发, 沿着网格线走, 一定会碰到石子.  

#### 2014_1C_3 思路  
我们的任务是在 N * M 网格中用最少的石子包围住至少 K 个交叉点.  
以下是一个 N=5, M=5, K=19 的示例.  
```text  
-***-   # the first row  
*XXX*   # intermediate row  
*XXX*   # intermediate row  
*XX*-   # intermediate row  
-**--   # the last row  
```  
注意到, 第一行和最后一行的石子是连续的, 中间行有两个石子.  
那么中间行可不可以有多于两个的石子呢? 比如以下情况:  
```text  
previous row:  --*XXX      -**XXX  
    next row:  **XXXX      *XXXXX  
                          (push up)  
```  
如右图所示, 多的石子总是可以上推, 转换为两个石子的情况.  
所以策略如下:  
1. 在第一行放一定数量的连续石子  
2. 在接下来的几行放两个石子  
3. 如果包围的数量足够, 在最后一行填上石子  

方法一: 动态规划  
每个状态需要知道的条件是:  
1. 剩下几行  
2. 左边界位置  
3. 右边界位置  
4. 还需要包围几个石子  
为了让左右边界的组合最少, 如果列数大于行数的话, 我们对网格进行翻转.  
但以上条件的组合还是太多, 时间复杂度太高.  
事实上, 左右边界的实际位置并不重要, 重要的是距离.  
每一次的可能结果是比上一行 -2, -1, 0, +1, +2.  
这样状态只剩 3 个: 剩下几行, 上一行左右边界距离, 还需要包围几个石子.  

方法二: 贪心法  
注意到, 在包围的交叉点数量不到一半时, 缩减和保持左右边界是没有意义的.  
同样地, 第一行有连续几个石子, 也可以向上扩展, 理想形状是菱形.  
所以我们可以试着构造菱形, 如果网格不够大, 再剪角.  
比如 N=6, M=7, K=27 的情况:  
```text  
--***--  
-*XXX*-  
*XXXXX*  
-*XXXX*  
--*XX*-  
---**--  
```  
网格中被剪掉的四个角都是直角三角形. 这让我们能暴力法枚举所有形状.  
注意到三角形的大小最多只相差 1.  
```text  
for i in range(2 * R):  
  cover = R * C  
  cover -= empty_triangle(i / 4)  
  cover -= empty_triangle((i + 1) / 4)  
  cover -= empty_triangle((i + 2) / 4)  
  cover -= empty_triangle((i + 3) / 4)  
  if cover < K:  
    break  
  stones = 2 * (R + C) - 4 - i  
  best = min(best, stones)  
```  
其中, R <= C, 即图形是扁长方形. i 是最上和最下两排剪去的石子的总数.  

  
### 2014_1C_2 reordering train cars  
Yahya 是个聪明的孩子, 时常提出有趣的问题. 今天的问题来自于爸爸买的小火车.  
车厢一侧写着一个小写字母. 几个车厢连成一组. 共有 N 组车厢.  
他觉得有效的火车, 应该所有相同字母都相邻.  
给定每组车厢的字母序列, 他想知道有多少种方法连接每一组, 才能形成有效的火车.  

#### 2014_1C_2 思路  
分为两步: 判断合法, 构造组合.  

第一步: 判断合法  
1. 检查每个字符串, 确保没有字母出现在两个不同地方.  
2. 记录每个字母出现在开始处, 结尾处, 中间处的 index.  
   记录每个字母出现在单字母字符串的次数.  

对于每一个字母, 检查它符合以下其中一个条件:  
1. 它只出现在一个字符串的中间处.  
2. 它只最多一次出现在字符串开始处, 最多一次出现在字符串结尾处.  

第二步: 构造组合  
相同字母的单字母字符串本身是一个组合. 缩成一个单字母字符串.  
如果某个字母的单字母字符串有 a 个, 有 a! 种组合方式.  
对于所有的非单字母字符串, 如果它的起始字母不是另一个字符串的结尾,  
以它为起始字符串, 首尾连接.  
对于单字母字符串, 如果它出现在起始或结尾处, 将它从组合中删去.  
最终假如有 n 个非连续字符串, 就有 n! 种组合方式, 再乘以单字母字符串的.  

  
### 2014_1C_1 part elf  
Vida 说他是混血精灵.  
但他不知道那个精灵祖先是哪一代之前的.  
和人类的混血一样, 一个有 A/B 精灵血统的人, 和另一个有 C/D 精灵血统的人,  
将生出一个有 (A/B + C/D) / 2 精灵血统的人.  
有一件事是确定的, 40 代之前, 每个祖先都是纯血精灵和纯血人类.  
Vida 知道自己有 P/Q 精灵血统.  
最近可能在第几代, 他有一个纯血精灵祖先? 或者他不可能有 P/Q 精灵血统?  

#### 2014_1C_1 思路  
首先, 在任何一代, 分母一定是 2 的次方. 所以, 我们首先确定不可能的情况:  
先将分数化简, 然后判断分母是不是 2 的次方.  
化简的方法是分母和分子除以他们的最大公约数.  
接下来的问题是, 给定 P/Q, 最近一代的 1/1 精灵在几代以前.  
小数据集:  
Q 最多为 1000, 我们可以枚举最近 10 代的可能组合.  
枚举的时候记录下他们的继承关系. 最后 BFS 第一次遇到 1/1 的时候记录下长度.  
大数据集:  
举个例子, 比如说 Vida 是 3/8 精灵, 他的可能父母血统是? 枚举如下:  
0/8 + 6/8, 1/8 + 5/8, 2/8 + 4/8, 3/8 + 3/8.  
从 0/8 到 6/8, 0 到 6 是连续的.  
也就是说, 一个 P/Q 的 Z/Q 父母, Z 最多可以是 min(Q, P*2).  
所以每往上一代, 父母血统最多是 P * 2, 直到找到 P >= Q.  

1234567890123456789012345678901234567890123456789012345678901234567890