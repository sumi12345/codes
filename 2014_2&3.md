### 2014_3_4 willow
Hanaa 和 Sherine 在玩 Willow, 一款棋盘游戏.
游戏有 N 座城市, 第 i 座城市有 Ci 个金币, 城市间有 N-1 条双向连通道路.
游戏规则如下:
Hanaa 和 Sherine 各选择一座城市作为起点. 可以选同一座城市. Hanaa 先走.
一个玩家经过一座城市时, 带走这个城市的金币, 后来到达的玩家无法获得金币.
一个玩家经过一条道路后, 道路就不能再被使用.
当双方玩家都无法移动到下一个城市时, 游戏结束.
记分方法是你的金币数减去对方的金币数.
如果双方都按最优策略进行游戏, Hanaa 最多能够获得多少分?

#### 2014_3_4 思路
问题可以描述为, 给一棵 N 个结点的树, 每个结点 i 有 Ci 个金币.
两个玩家选择一个初始结点, 向相邻结点移动. 
两个玩家的路径只可能在 1 个结点相交(因为没有环).
对于一个给定的 p1 起点, 最终得分是 p2 选择 1-N 结点中让 p1 得分最低的那个.
所以 p1 要选择 1-N 结点中, 最低得分最高的那个.
所以现在的问题是, 给定 p1 的起点和 p2 的起点, 如何计算 p1 的得分.

方法一: DFS 回溯法
rec(i, j, turn)
i 是当前玩家上次选择的结点, j 是另一个玩家上次选择的结点, turn 是玩家 ID.
检查当前玩家上次选择的结点 i, 查看所有相邻结点 ni, 交给对方走.
取所有相邻结点 ni 中, 负的对方成绩中, 最大的那个.
如果 i 没有相邻结点了, 即自己已经动不了了, 成绩即是负的对方成绩.
最后拿走城市 i 的金币.

方法二: 动态规划
注意到, 玩家从一个结点移动到新结点之后, 两个结点之间的边就被切断了.
如果新结点和另一个玩家的上一结点不连通, 那两个玩家只需考虑在各自子树中如何行动.
每个状态中, 当前玩家只有两种选择:
1. 选择靠近另一玩家的结点
2. 选择远离另一玩家的结点
因为给定的模型是一棵树, 所以连接双方玩家的上一结点只有一条路径.
所以选择靠近另一玩家的结点, 双方玩家还在一棵子树上, 递归计算新状态.
选择远离, 双方就不在一棵子树. 双方只需考虑在各自子树中的行动, 可以停止递归直接计算.
rec 方法如下:
```text
rec(i, pi, j, pj): 当前玩家的上一条边 pi->i, 和另一玩家的上一条边, pj->j
如果 i == j, 两个玩家相遇, 
    当前玩家选择下一最佳路径, 终点 ni = next_best_except(i, pi, pj);
    另一玩家选择再下一最佳路径, 终点 nj = next_best_except(i, pi, pj, ni); 
    返回 ni 到 i 的金币 - nj 到 j 的金币;
如果 i != j:
    选择 1: ni = 接近另一玩家的新结点, 双方玩家还在一棵子树上;
            option1 = -rec(j, pj, ni, i) + 中间结点 ni 的金币;
    选择 2: p1coins = next_best_except(i, pi, ni) 远离另一玩家的最佳路径金币;
            p2coins = branch_off_between(i, pi, j, pj) 在走向 i 的路径中转向;
            option2 = p1coins - p2coins;
    返回两个选择中较大的那个;
```
branch_off_between 方法如下:
```text
branch_off(i, pi, j, pj): 在结点 i, j 之间随时转向能获得的最大金币;
如果 i = j:
    i 选择此结点出发的最佳路径, 终点 ni = next_best_except(i, pi, pj);
    j 选择此结点出发的再下一最佳路径, 终点 nj = next_best_except(i, pi, pj, ni);
    返回 nj 到 j 能获得的金币
如果 i != j:
    nj = 从 j 到 i 的下一个结点;
    njb = 从 j 出发的远离 i 的最佳路径的终点结点 next_best_except(j, pj, nj);
    branch_off_now = 从 j 到 njb 能获得的金币;
    branch_off_later = branch_off_between(i, pi, j, nj) + 中间结点 nj 的金币;
    返回 branch_off_now 和 branch_off_later 中较大的那个;
```


### 2014_3_3 crime house
在帮助警方破案的时候, 警察已经发现了一个犯罪窝点, 并在门口安装了摄像头!
你不知道记录开始的时候房间里有多少人, 也不知道是不是有另一个门.
但你能看到每一个人的出入. 不幸的是, 有人戴了面具. 他们不戴面具的时候, 能认出是谁.
你有一整天的视频记录. 你是个乐观主义者, 你想知道是不是有可能没有另一个门.
如果没有另一个门的话, 在视频结束之后, 最少还有多少人留在房间里.

#### 2014_3_3 思路
首先, 我们假设屋子里没有人戴面具. 接下来只要检查序列是否有效即可.
遇到一个 'E X' 时, X 已经在屋子里, 或遇到 'L X' 时, X 不在屋子里, 无效.
假设屋子里原来有 S 个人. 在序列前面加上 S 个 'E 0'.
假设所有人最后都离开屋子, 在序列后加上 T 个 'L 0', 使 E 和 L 数量相等.
模拟过程如下:
E X: 检查 X 在不在屋子里, 如果不在, 让 X 进屋.
L X: 检查 X 在不在屋子里, 如果在, 让 L 离开.
E 0 (a): 检查已知 ID, 选择不在屋子里, 下一个事件是 L, 发生时间最早的.
E 0 (b): 如果没有人符合 a 条件, 创造一个新 ID, 让它进屋.
L 0 (a): 检查所有在屋子里的人, 选择下一个事件是 E, 发生时间最早的.
L 0 (b): 如果没有人符合 a 条件, 检查所有在屋子里的人, 选没有后续事件的.
L 0 (c): 如果没有人符合 b 条件, 检查所有在屋子里的人, 选 L 时间最晚的.
S 的选择范围从 0 到 N (事件总数), 且如果 S 是有效的, S + 1 也是有效的.
所以只要找到一个让序列有效的最小 S, 计算最后在屋子里有多少人即可.

自己的方法:
记录所有 LL 间隔和 EE 间隔, -1 到 X 的第一个 L 也是 LL, 最后一个 E 到 N 也是 EE.
按序号从小到大分配 L 0, 给 EE 间隔, 每次选择结束时间最早的.
按序号从大到小分配 E 0, 给 LL 间隔, 每次选择开始时间最晚的.
按序号从大到小分配剩下的 E 0, 找到开始时间最早的 EL 间隔, 
用掉间隔中最早的 L 0, 产生 EX L0 E0 LX.

### 2014_3_2 last hit
Diana 需要你帮他在最喜欢的游戏中赚到尽可能多的金币!
经常出现的场景是, 他站在他的塔前, 面对 N 个怪兽.
他和塔轮流向怪兽发起攻击. 
他可以选择任何怪兽攻击, 也可以不攻击. 塔每次攻击离塔最近(编号最小)的怪兽. 
如果他攻击怪兽, 怪兽的生命值减 P, 如果塔攻击怪兽, 怪兽生命值减 Q.
如果怪兽的生命值降到 1 以下, 就被消灭了. 第 i 个怪兽有 Hi 的初始生命值.
如果他向怪兽发起攻击并且消灭了怪兽 i, 会得到 Gi 个金币的奖励.
如果塔的攻击消灭了怪兽, 则没有金币奖励. 他最多能获得多少金币?

#### 2014_3_2 思路
动态规划: 每次决定是积累空回合, 还是用掉积累的空回合.
f(i, remain_hp, extra_shot)
第 i 个怪兽, remain_hp 是这个怪兽剩下的生命值, extra_shot 是积累的空回合.
1. 当前怪兽已经被消灭, 转向下一个怪兽.
2. Diana 用积累的空回合攻击怪兽, 可以的话消灭怪兽并得到金币.
把 extra_shot 当成是, 塔每打击一次释放的资源就行了.
塔每打击一次, 释放一个 extra_shot, 每一个 extra_shot 只能用来打击一个怪.
不用考虑回合.
对于每一个怪, 最佳策略是等塔打到差一下消灭, 考虑要不要补最后一刀.


### 2014_3_1 magical, marvelous tour
电子元件工厂老板决定做一件大事! 
他在 7 个电子设备中藏了黄金晶体管, 买到这些设备的人可以获得神奇的工厂之旅.
Arnar 和 Solveig 得到一个消息, 一家电子商店中有一个设备藏着黄金晶体管.
所以他们凑钱把这家店所有的电子设备都买了下来, 一字排开, 编号 0 到 N-1.
首先, Arnar 选择一个范围 [a, b]. 
Solveig 选择 [0, a-1], [a, b], [b+1, N-1] 3 个范围中的 1 个.
Arnar 获得剩下的设备.
已知每个设备中有多少晶体管, Arnar 和 Solveig 都会最大化获得晶体管的数量.
Arnar 获得黄金晶体管的概率是多少?

#### 2014_3_1 思路
先计算从 0 到每个元素的累加值, 保存在数组 sum 中.
假设 Arnar 选择的范围是 [i+1, j], 
Solveig 的选择就是 sum[i], sum[j]-sum[i], sum[N-1]-sum[j] 中的最大值.
所有元素之和为 total.
i 是前缀和小于 total/3 的最大值, j 是前缀和大于 total/3*2 的最小值.
缩小边界, 尝试所有 sum[j]-sum[i] >= total/3 的划分.


### 2014_2_4 trie sharding
一组字符串 S 被存储在前缀树 trie 中.
我有一个服务器, 将 S 以 trie 的形式存储. 
但是 S 变得非常大, 不得不将它存储在 N 台服务器中, 每台服务器存储S的一个子集.
给定 S 和 N, 最糟情况下, 最多有多少结点? 最多结点的情况有多少种子集划分方法?
注意 N 台服务器是不同的. 输出最终结果模除 1,000,000,007.

#### 2014_2_4 思路
S 中有 M 个不同字符串. 将他们分配到 N 个服务器, 每个服务器至少有一个字符串.
首先我们建立 S 的前缀树.
对于一个前缀 p, 记 T_p 为包含前缀 p 的字符串数量.
在最优分配方法中, 我们假定前缀 p 重复尽量多次, 但重复次数不会超过 T_p 和 N.
记 K_p 为 min(T_p, N).
所以问题转换为尽量使每个前缀 p 出现 K_p 次.

如何计算最多结点数?
首先, 我们将 S 中的字符串以字典顺序排序. 这样相同前缀在序列中是连续摆放的.
使用贪心法分配. 将排序后的 S 中, 第 i 个字符串分配给 i % N 号服务器.
这样能保证前缀 p 重复 K_p 次. 因此 K_p 的和即是最多结点数.

如何计算结点最多的分配方案数量?
在开始解答之前, 我们先来说说排列组合. 我们可以用杨辉三角事先计算排列的值.
记 Choose(n, k) 为从 n 中选择 k 的组合数.
假定我们已经建好了 S 的 trie, 计算好了每个结点的 K_p.
我们可以通过后序遍历, 来计算某个前缀的分配方案数量 W_p.
先考虑叶子结点. 
对于叶子结点, 它只能重复 1 次, K_p = 1. 在 1 个服务器上放 1 个结点, W_p = 1.
对于非叶子结点.
记 K_c 为每个子结点 c 被分配到多少台服务器.
记 W_c 为每个子结点 c 的重复最多次数的分配方案数.
记 K_p 为结点 p 最多能被分配到多少台服务器. 
子结点被分配到某一台服务器, 它的所有父结点都要被分配到这台服务器, K_p >= K_c.
要计算 p 的 W_p, 我们首先应该计算:
C1: 将所有子结点 c (分别必须占 K_c 台) 分配到 K_p 台服务器, 有多少种方法.
C2: 每个子结点 c, 将它的子树分配到 K_c 台服务器有多少种方法.
W_p = C1 * C2.
C2 = 它的所有子结点 c 的 W_c 的乘积.
C1 的计算可以等同于另一个典型问题:
有若干种颜色的彩球, 每种颜色 c 的彩球数量有 K_c 个, K_c <= K_p,
要将彩球分配到 K_p 个盒子, 让每个盒子不空, 也不含颜色相同的彩球.

彩球问题:
我们先不考虑每个盒子不空的条件, 只考虑每个盒子不含同颜色彩球的条件.
假设某颜色彩球有 x 个, 盒子有 K 个. 它必须分到 x 个盒子, 分配方法有 C(K, x).
记 OC_K 为盒子有 K 个时所有颜色的分配方法的乘积.
事实上, 我们需要计算从 1 到 K 的所有 OC_i.
记 Count_i 为, 盒子为 i 个时, 没有空盒子的分配方法数量.
则 OC_i 为 Count_a * Choose(i, i-a) 之和, a 从 1 到 i.
将公式变形一下, 我们可以递归地计算 Count_i:
Count_i = OC_i - sum(Count_a * Choose(i, i-a)), a 从 1 到 i-1.


### 2014_2_3 don't break the Nile
外星人登陆地球了. 他们发现地球的河流很有趣, 因为他们的星球没有河流.
他们想在河流上造建筑物. 你的任务是确保他们的建筑物不会阻塞河流.
他们选择河流中等宽的一段. 因此你的研究模型是一组网格, 南面入水, 北面出水.
每个网格的水容量为 1. 给你这个网格, 你能计算出最终的出水容量是多少吗?

#### 2014_2_3 思路
贪心法:
爬墙. 每次靠紧左手边的网格爬.

最大流算法:
每个网格是一个顶点. 非建筑相邻顶点间的边的容量为 1.
南面的所有非建筑网格连接源点, 北面所有非建筑网格连接汇点. 
计算源点到汇点的最大流.
但这个方法比较慢, 解决不了大数据集.

最小割:
最大流问题是最小割问题的对偶问题.
在这个问题中, 最小割问题比最大流问题更容易解决.
对于这个问题, 我们只需要找到一条横向路径, 以完全阻断纵向的水流.
所以问题转换为: 找到一条从河流左边到右边的最短路径.
顶点是建筑物, 边的权值是两个建筑物之间的最短距离, 即连接两建筑物所需的网格数.
源结点为左边缘, 汇结点为右边缘, 他们与每个建筑物之间都有边.
找从源结点到汇结点的最短路径.


### 2014_2_2 up and down
给你一个序列 A = [A1, A2, A3, ..., AN].
要重新排列成 A1 < A2 < ... < Am > Am+1 > ... > AN 这样的序列.
排列通过交换相邻元素完成. 给你一个序列, 至少需要交换多少次?

#### 2014_2_2 思路
从数字小的开始, 考虑将它移到左边缘近, 还是右边缘近. 向近的那边移动.


### 2014_2_1 data packing
Adam 特别喜欢整理东西. 尤其喜欢将电脑上的文件放进光盘.
他整理文件有两个原则. 
第一, 绝不在一个光盘放两个以上的文件, 第二, 绝不将一个文件分在两个光盘.
给你文件大小和光盘容量(所有光盘容量相等), 你能告诉他, 至少需要多少光盘吗?

#### 2014_2_1 思路
从最大的文件开始, 如果有小文件可以放在同一光盘, 就放一个盘. 否则自己一个盘.