### 2010_2_4 grazing google goats  
牧民 John 刚刚买了一个有 N 只羊的羊群.  
每只羊 i 都会绑在一根柱子上, 柱子的位置是 Pi, 绳子的长度是 Li.  
这意味着这只羊的活动范围就在以 Pi 为圆心, Li 为半径的圆中.  
他的牧场已经有了柱子, 现在他要决定绳子的长度. 他要考虑如下两个因素:  
1. 所有的羊都必须能到达一个水桶. 他还没有决定好水桶放哪, 只定了几个候选位置.  
2. 羊的脾气不太好, 聚在一起可能会打架, 要尽量减少所有羊都能到达的区域的面积.  

对于每一个水桶候选点, 决定绳子长度, 给出所有羊都能到达的区域的面积的最小值.  

#### 2010_2_4 思路  
我们将证明, 整个概念跟凸壳问题是很类似的. 并且最后的代码量并不很劝退.  
一次只考虑一个桶 Q. 题目让我们选择绳子长度, 即选择每根柱子的半径长度.  
共同区域将是所有圆的交集. 很明显应该尽量减少半径, 选择刚好到达桶的长度.  
所以解题的重点在于, 如何高效地计算共同区域的面积.  
最终的形状是一个凸多边形, 每一条边都是一个弧. 每根柱子最多只提供一条边.  

理论背景(没看懂):  
首先, 注意到所有的圈都经过同一个点 Q.  
下面我们介绍一种几何变换, inversion, 逆.  
将 Q 作为中心, 每一个非 X 的点都被映射到另一个点 X'.  
QX 和 QX' 在相同方向, 并且 |QX||QX'| = 1.  
逆有一个非常有趣的性质: 每一个经过 Q 的圆都能被映射到一条不经过 Q 的线.  
而圆的内部可以被映射到一个不包含 Q 的半平面上.  
在我们的问题中, N 个圆的交集就被映射为 N 个半平面的交集.  
可以查维基百科的 [inversive geometry] 词条了解更多性质.  
如果交集非空, 我们可以旋转平面, 让 Q 处在所有的半平面上.  
这时所有半平面的交集的边界, 被称作 lower envelope of line arrangements.  
而 lower envelope 的线段就是原始问题中弧的镜像.  
计算几何中还有一个概念, 对偶. 将直线 y = ax + b 映射到点 (a, -b).  
lower envelope 通过这个转换, 映射到一组对应点的凸壳.  
所以问题等价于凸壳问题, 和 lower envelope of line arrangements 问题.  
总结算法: 将这些线按斜度排序, 一个一个加上去.  
每一步, 现有的 lower envelope 会被新直线切割成两部分.  
排序的复杂度是 O(N log N), 而剩下的工作复杂度是 O(N).  

解法(没看懂):  
...  


### 2010_2_3 bacteria  
一些细菌躺在无限的网格中. 每个细菌占一个网格.  
每一秒, 细菌会发生如下变化:  
1. 如果上方和左边都没有细菌, 那这个细菌会死亡;  
2. 如果一个网格本来没有细菌, 但是上方和左边都有细菌, 这个网格会长出新的细菌.  

给你网格中细菌的分布, 你能计算出, 过多少秒, 全部的细菌都会死亡吗?  

#### 2010_2_3 思路  
事实上, 输入给的方块, 跟解题思路一点关系都没有, 要回到原始设定考虑问题.  
可以试试以下几个例子:  
1. H x W 方形的细菌;  
2. H x W 方形, 细菌只分布在四条边上;  
3. / 形对角线分布的细菌 (类型1);  
4. \ 形对角线分布的细菌 (类型2);  
5. 只以横向, 纵向, 和 / 方向相连的细菌;  

如果你做完了以上几个实验, 你应该会得到一些灵感.  
如果一个 / 形对角线 (类型1) 在另一个 / 的左上方, 我们说它比较高.  
如果最初的图案是相连的, 且最高的 / 形对角线在 X + Y = C,  
最右边的点在 X = Xmax, 最下方的点在 Y = Ymax.  
我们说, 一回合后, 图案仍然是相连的,   
最高的对角线变成 X + Y = C+1, 而最大的 X 和 Y 坐标保持不变.  
每一回合都是如此, 直到图案缩小到只有一个点 (Xmax, Ymax).  
所以经过 Xmax + Ymax - C + 1 回合, 所有的细菌都会消失.  

证明:  
命题1:  
如果旧状态是一个相连的图案, 且最高的 / 形对角线是  X + Y = C,  
那么在新状态中, 最高的 / 形对角线会变成 X + Y = C+1.  
证明: 想象一个在 (X, Y) 坐标上的细菌, 它在旧状态的最高的 / 形对角线上.  
它的上方和左边都没有邻居, 所以它下一秒不会存在, 事实上 X + Y = C 都会空.  
现在挑选 X + Y = C 线上最下方的一个细菌, 假设它的坐标是 (X, C-X).  
如果原来 (X+1, C-X-1) 坐标上有细菌, 那么新状态上 (X+1, C-X) 也会有细菌.  
如果没有, 因为 (X, C-X) 是相连图案中的一部分,  
所以 (X, C-X+1) 或 (X+1, C-X) 中至少一个坐标有细菌, 而它会继续存在.  
所以 X + Y = C+1 线上至少会有一个细菌.  
同理可以证明以下的命题.  
命题2:  
如果旧状态是一个相连的图案, 在新状态中, 最大的细菌 X 和 Y 坐标保持不变.  
命题3:  
如果旧状态是一个相连的图案, 新状态也是一个相连的图案.  
命题4:  
如果在新状态下, 两个细菌是邻居, 那么他们都来自旧状态的同一块相连的图案.  


### 2010_2_2 world cup 2010  
经过了 4 年的等待, 南非世界杯终于开赛啦.  
Varva 已经在去南非的路上, 等他到了正好可以赶上第二阶段的比赛.  
第二阶段是淘汰赛. 每场比赛的赢家, 可以参加下一轮比赛, 输家则就此退出.  
参赛队伍总共有 2^P 支, 编号 0 到 2^P-1, 按编号顺序两两对战.  
Varva 列了一个表格, 对队伍 i, 他最多愿意错过 M[i] 场比赛.  
他需要买一组门票, 来保证他的球队偏好得到满足. 同时他想尽量节省花销.  
你的任务是帮他算出, 满足条件的方案最少需要花多少钱.  

#### 2010_2_2 思路  
我们把这张图倒过来看, 这也符合我们看二叉树的习惯, 根节点在最上方.  
这样我们得到一棵有根节点的完全二叉树, 中间结点是比赛, 叶子节点是队伍.  
我们将使用动态规划.  
如果我们将会购买这个比赛的门票, 就将这个节点标识为黄色.  
从某队伍到根节点的路径上有多少黄色节点, 代表购买这个球队的多少场门票.  
最多愿意错过 M[i] 场比赛, 即从队伍 i 到根节点上至少有 P-M[i] 个黄色结点.  

小数据集: 所有门票价格都为 1.  
对小数据集, 最好的办法是沿着从根节点到每个队伍的路径, 买 P-M[i] 张门票.  

大数据集: 门票价格从 0 到 100000 不等.  
对于任意结点 a, 和从 0 到 P 的任意数字 b, 定义 P(a, b) 为:  
如果从根结点到 a 的路径上(不含 a)有 b 个黄色结点,  
如何标识以 a 为根结点的子树上的结点, 才能在符合条件的前提下, 花最少的钱?  
P(a, b) = min(  
price[a] + P(2\*a+1, b+1) + P(2\*a+2, b+1),  
P(2\*a+1, b) + P(2\*a+2, b)  
)  
返回 P(0, 0).  


### 2010_2_1 elegent diamond  
国王雇佣你给他做一枚优雅的钻石.  
一枚钻石是菱形的, 水平对称, 垂直对称. 比如以下 4 个形状是优雅的钻石.  
```  
   2       8      3     7  
  3 3     8 8    2 2  
 4 1 4     8      3  
  3 3  
   2  
```  
国王会给你一个初始的钻石, 它可能不是优雅的, 所以你要加强它.  
通过增加数字来让它变得优雅.  
你不想花太多钱, 所以你想尽量减少花销.  
花销的定义是, 加强之后的数字数目, 减去原来的数字数目.  

#### 2010_2_1 思路  
换个角度思考问题: 给你一个坐标(cx, cy), 可不可能以它为中心加强钻石呢?  
这意味着最终的钻石, 将以 x=cx, y=cy 为轴对称.  
如果现有钻石有不对称的数字, 那就不可能以这个坐标为中心加强钻石.  
否则, 我们总是有办法加强它.  
所以我们只要遍历所有可能的中心点, 检查现有数字是否关于它对称,  
计算最终钻石的大小, 找出最终结果最小的那个.  


### 2010_3_4 different sum  
一个密码方程式是这个形式的, 所有的加数, 以及和, 都右对齐排列.  
```  
124  
 31  
 25  
---  
180  
```  
另外, 密码方程式的每一列, 所有数字都必须是不同的.  
因此上面的式子不是一个密码方程式, 但如果最后一个加数改为 15, 就是了.  
加数总是正整数, 且没有先导 0. 加数的顺序不重要.  
加数可以是 10 进制的, 也可以是其他进制的.  
给你和 N, 和进制 B, 你能写出多少个密码方程式?  

#### 2010_3_4 思路  
小数据集:  
枚举 N 的所有划分方式, 然后检查每一列是否都是不同的数字.  
但是 100 的划分方式有 190569292 种. 限制每个加数不同, 可以减少到 444793.  
还可以通过回溯法, 一边检查每一列是否都是不同的数字, 来进行剪枝.  

大数据集:  
我们需要把思路改为从右往左. 先产生最右一位, 依次往左.  
假设我们已经产生了最右几位.  
在这一位, 我们关心的只有: V, 进位. K, 加数数量. F, 上一位是否以 0 开始.  
所以我们可以用动态规划.  
记 Count[i, V, K, F] 为填满后 i 位的方法.  
V 是进位. K 是加数的数量. F 标识是否有加数以 0 开始.  
给定算好的 Count[i,...], 要计算 Count[i+1,...],  
我们要考虑, 将从右数起第 i+1 位, 划分为最多 K 个数字相加的方法.  
K 最多为 B, 而 B 在大数据集中最多为 100, 全排列的值是很大的.  
但是注意到, 我们不需要具体数字, 我们只需要他们的数量.  
记 Count2[K, S, F] 为将 K 个不同的数字放在同一列, 他们的和为 S 的方法数.  
K 最多为 B, S 为 O(B^2), 所以状态最多为 O(B^3) 个.  


### 2010_3_3 hot dog proliferation  
一些热狗小贩开始在街上卖热狗.  
这是一条东西向的, 非常长的街.  
问题是, 可能会有几个小贩在同一个角落卖热狗, 这样会抢彼此的生意.  
他们的解决方法是, 如果有两个及以上的小贩在同一个角落卖热狗,  
那么有 2 个小贩要进行一次移动:  
一个向东移动一个角落, 另一个向西移动一个角落.  
给你小贩们的初始位置, 他们至少需要进行多少次移动, 才能全都分开?  


### 2010_3_2 fence  
我们想建造一条非常长的围栏.  
我们已经选好了地址. 剩下的工作就是收集材料了.  
在当地的五金店, 我们可以买到无限数量的木板, 木板有它们的固定长度.  
为了避免浪费, 我们想让买到的木板总长度正好等于要建造的围栏的总长度.  
给你围栏的总长度, 和原材料木板的各种长度, 你至少要买多少块木板?  
注意: 围栏可能会非常长!  

#### 2010_3_2 思路  
小数据集: 木板长度 <= 100.  
我们先从一个简单一点的问题开始. 假设最长的木板长度 A <= 100.  
长度小于 A 的木板, 数量不应该大于 A.  
否则我们可以将 A 个这样的木板替换成更少数量的长度为 A 的木板.  
比如 80 * 100 = 100 * 80.  
这意味着短木板的总长度最多是 N * A * A <= 1000000.  
使用广度优先遍历, 我们就能找到选择这些木板的方法.  
长度为 A 的木板使用数量, 简单除法就可以.  
大数据集的证明其实最大长度可以减到 A * A.  

大数据集: 木板长度 <= 100000.(没看懂?)  
小数据集的解决方法并没有利用到木板的最短长度.  
我们知道, 最终我们要大量使用最长木板.  
假设最长木板的长度为 A, L = p * A + q, q < A, p >= A.  
我们接下来要做以下工作:  
使用 T(0, q) 个短木板构建长度为 0 * A + q 的围栏, 用 p 个最长木板.  
...  
使用 T(p, q) 个短木板构建长度为 p * A + q 的围栏, 用 0 个最长木板.  
答案是 p + S(p, q).  
S(p, q) = min(T(0, q)-0, T(1, q)-1, ..., T(p, q)-p).  
S(p, q) 可以理解为要让围栏长度达到 q % A 要使用的最少木板数量.  

证明: T(i, q) - i 在 i > q 时不是最优的.  
我们有一组木板 {b1, b2, ..., bm} 组成长为 i*A + q 的围栏.  
如果 i > p, 那么 m > p >= A,  
组合 {b1, b1 + b2, ..., b1 + b2 + ... bm} 中至少有 A + 1 个不同的数字.  
其中两个模除 A 的值一定是相等的. 除去他们, 我们可以得到一个非空子集  
{b1, b2, ..., bm}, 他们的和是 A 的整数倍, 就可以替换成 A,  
所以 i > p 时 T(i, q) - i 不可能是最优的.  


### 2010_3_1 De-RNG-ed  
我想做一个在线扑克网站.  
这样的网站最重要的, 是随机数生成器. 需要足够快, 也足够随机.  
我想到了一个折中方案.  
要产生 D 位随机数字, 我的计划是, 找到一个质数 P, P <= 10^D.  
选择两个非负整数 A 和 B, 再选择一个种子 S, 0 <= S <= P-1.  
首先输出 S. 然后更新 S 为新的值: S = (A * S + B) % P.  
新的值就是随机数序列中的新成员, 依此类推.  
你认为这是一个好的随机数算法吗?  
给你一个长度为 K 的随机数序列, 序列中的成员都是按上述方法产生的,  
你能给出序列中的下一个成员吗?  

#### 2010_3_1 思路  
(没看懂如何解出 A)  
找到下一个成员意味着找到符合条件的 A, B 和 P 的值.  
如题所述, 序列中的所有数字都小于 P, 且 P < 10^D, 符合以上条件的质数列为候选.  
现在我们看一些特殊情况.  
K = 1: 答案永远都是 "I don't know".  
K = 2, 且两个元素相同: 因为下一个元素完全由这个元素决定, 所以接下去都相同.  
K > 2, 且序列中所有元素都相同: 同理接下去也都相同.  
K = 2, 且两个元素不同: 答案也是 "I don't know", 因为 A=0, A=1 时都成立.  
K = 3: 枚举所有 P 的候选, 解出 A 和 B, 如果结论都相同, 则唯一, 否则不确定.  
K > 3: 枚举所有 P 的候选, 靠前 3 个元素解出 A 和 B, 检查剩下的元素是否相符.  
