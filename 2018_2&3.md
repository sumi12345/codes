1234567890123456789012345678901234567890123456789012345678901234567890
### 2018_2_4 gridception
Jom Codd 是一个盗梦大师.
观察梦境的技术还很不成熟, Codd 看到的梦境是一个由黑白格子组成的网格.
给定一个起始梦境网格, Codd 可以"深入"这个梦境.
"深入"的方法是, 将一格替换为 2x2 个同颜色的网格, 即扩展为原来的 4 倍.
Codd 刚刚入侵了一个梦境, 看到了它的初始梦境网格.
他知道他必须"深入"这个梦境多次. 为了导航, 他在寻找特定的"花纹".
一个"花纹"包括一组边相连的网格, 加上它们的颜色.
花纹可以是中空的. 如果两个花纹的网格有相同的数量和排列, 则他们相同.
Codd 想知道起始梦境中是否存在一个花纹, 在"深入" 10^100 次之后的梦境中,
依然存在. 输出这个花纹的网格数量.

#### 2018_2_4 思路
小数据集: 1 <= R <= 3, 1 <= C <= 4
完全搜索就可以解决. 枚举所有的花纹. 检查它是否存在于深入 2 遍的网格.
注意深入 1 遍的图案是不够的. 至少每个格子要扩展到 4 x 4, 即深入 2 遍.
最多有 O(2^(R * C)) 种花纹, 深入需要 O(R x C) 时间.

大数据集:
R 和 C 最多可以到 20. 上面的方法太慢.
我们不能枚举所有可能的花纹了.
观察到, 每一个可能的花纹会与最多 4 个深入之后的格子重合.
这意味着, 花纹必须能够分成 4 份, 横一刀, 竖一刀, 每一份颜色相同.
然后我们考虑所有可能的四分中心 (最多有 2^4 x R x C) 个,
对于每个四分中心和特定颜色, 找到尽可能多的连接的同颜色的网格.
找到最大连接分量需要 O(R x C).


### 2018_2_3 costume change
Supervin 是一个著名的编舞家. 今天是他职业生涯的 N 周年纪念日.
为了庆祝, 他打算排一个 N x N 的舞蹈队形.
每个舞蹈演员都有演出服, 每套演出服有一个颜色, 材料是羊毛或棉.
演出服有 N 种颜色可选. 每个舞蹈演员都想自己是特别的. 
如果同一行或同一列有两个舞蹈演员穿相同颜色和材料的演出服, 就不特别了.
Supervin 想让所有的演员都是特别的, 所以他想改一些演出服.
他最少需要改多少套演出服?

#### 2018_2_3 思路
小数据集:
每个演员试过去太慢. 即使是小数据集.
这个问题可以转换为,
找到最大子集, 子集中所有同一行同一列的演员的演出服都不同.
然后修改不在子集中的演员的演出服.
所以遍历所有的子集, 找到最大的那个即可.

大数据集:
我们需要一个更有效的找到最大子集的方法.
定义 f(x) 为穿演出服 x 的演员的最大的子集, 他们不在同一行,
同一列同时出现.
所以最终的子集可能是 f(i) 之和, 其中 -N <= i <= N, (i != 0).
我们怎么找到 f(x) 呢? 我们创造一个二分图:
1. {Ai} 是一组节点, 表示一行.
2. {Bi} 是另一组节点, 表示一列.
3. 当第 i 行和第 j 列有演员穿演出服 x, 为 Ai 和 Bj 加一条边.
找到二分图的最大匹配.


### 2018_2_2 graceful chainsaw jugglers
你是一个电锯杂耍团的经理.
你有无限的天才杂耍者, 每个都能耍任何数量的电锯.
要进行一场表演, 你会选择一些杂耍者, 将你的红色电锯和蓝色电锯分给他们.
每个人至少分到一个电锯. 一个电锯只能被一个杂耍者使用.
根据你的市场调研, 你的观众喜欢看到尽可能多的杂耍者和电锯,
但是不能有两个杂耍者, 使用的红色和蓝色电锯数量都相同.
你有 R 把红色电锯, 和 B 把蓝色电锯, 你必须把它们全部用上.
你的演出中最多能有多少杂耍者?

#### 2018_2_2 思路
小数据集:
把问题转换为, 在 V = [0; B] x [0; R] 的集合中, 找到一个子集, 
使得 b 之和为 B, r 之和为 R.
小数据集中, V 很小, 可以用动态规划. 类似背包问题.
定义 f(i, b, r) 为, 只考虑前 i 个 b-r 对, 找出一个数量最多的子集,
使蓝色之和为 b, 红色之和为 r.
时间可能要 (B + 1)^2 * (R + 1)^2.
一个提速的办法是, 对于所有的 case, 同参数的 f 结果相同, 可以记录查表.

大数据集:
针对这个问题, 有几点观察.
定义 br-valid 组为蓝色之和 = b, 红色之和 = r.
定义 week-br-valid 组为蓝色之和 <= b, 红色之和 <= r.
week-br-valid 组的一个特点是, 对于特定的 b 和 r, 他的最大元素数量 X,
等于 br-valid 组的最大元素数量 Y.
定义 minimal-week-br-valid 组为一个 week-br-valid 组 S.
S 中的任意 b-r 对 (i, j), 
i > 0 时, (i-1, j) 也在 S 中. 同样的, j > 0 时, (i, j-1) 也在 S 中.
可以证明, 对特定的 b 和 r, 最大的 minimal-week-br-valid 组的大小,
等于最大的 week-br-valid 组.
现在问题转换为, 找到特定 b 和 r 的最大 week-br-valid 组的大小.
根据最小原则, 如果 (i, j) 在集合里, 那 (i-1, j), (i, j-1) 也在集合里.
对于给定的 (i, j), 如果它在集合里,
则红色的和至少为 (j + 1) * (1 + 2 + ... + i) = (j + 1) * i * (i + 1)/2
同样蓝色的和至少为 (i + 1) * j * (j + 1)/2.
所以我们可以使用这个 i, j 形成组合 V', 进行动态规划. 比 V 小得多.


### 2018_2_1 Falling Balls
有一种玩具, 由 1 行以上, 2 列以上的网格组成, 每格是 \ 或 / 或空.
最左最右的列为空, 最后一行也为空.
球从第一行落下, 遇到隔板改变列, 最终落到最后一行.
你的朋友有一个这样的玩具, 有 C 列, 行未知.
他在第一行的每一列都扔下一颗小球. 记录最后每一列有几颗小球. 给你结果.
但你觉得结果可能有错. 
你能创造一个与结果一致的, 行数最少的玩具吗? 或者指出这不可能.

#### 2018_2_1 思路
如果第一行和最后一行小球的数量为 0, 不可能.
接下来, 哪个入口的小球落在哪个槽, 是确定的, 没有异议.
然后构造一个全空的玩具, 哪个球需要落在哪个槽, 就连续放几个斜坡.
