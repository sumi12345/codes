### 2018_3_4 fence construction  
你是围栏建造公司的一名员工. 任务是建造 F 个围栏.  
每个围栏是一条线段. 也就是说, 每个围栏是平面上两个点之间的连线.  
围栏彼此不相交, 除非在端点上. 围栏都在端点相互连接.  
你开始工作的时候还没有围栏. 建造使用喷射式 3D 打印机. 打印机只有一台.  
要建造围栏 f, 你将打印机放在平面上某点 p, 使得打印机能看见 f 所占区域.  
p 要满足以下条件:  
1. p 不在 f 上.  
2. 对于 f 上的任意一点 q(q 不是端点), p 和 q 的线段不与已存在围栏相交.  
要放置打印机, 你可以以连续的路径移动它, 只要不跨越已有围栏.  
以上条件决定了, 不能以任意顺序建造. 因为有可能阻挡打印机的移动路径.  
负责人已经确定了其中 K 个围栏建造的相对顺序(还没建造), 但他没考虑太多.  
为了避免他生气, 你必须使用这个顺序, 再插入建造剩下的 F-K 个围栏.  
根据以上条件, 找到一个建造围栏的顺序. 题目保证至少有一个可行方案.  

#### 2018_3_4 思路  
小数据集: 1 ≤ K ≤ 2  
我们将题目转换为图, 端点是顶点, 围栏是边.  
首先假定没有预定顺序, 即 K=1.  
有许多贪心法可以建造围栏, 比如从外到内, 或从内到外, 使用凸壳算法.  
每种方法有它的优缺点, 但是他们中很多个顺序反过来也成立.  
所以小数据集 K=2 的时候, 可以将贪心算法的答案反过来.  

还有一种方法, 比较容易描述, 证明和实现.  
建造 G 的任意生成树 T, 包含围栏 1. 这样顺序就保证了.  
我们现在建造了一组没有环的围栏. 现在任何其他围栏都是可以到达的.  
对于剩下的围栏 f, 考虑当 f 被加入 T 时形成的环. 这个环是一个凸多边形.  
我们按顺序建造这个环的所有边即可, 只要保证打印机总是在闭环之外.  

大数据集: 1 ≤ K < F  
构造 G 的对偶图 H. 记 G(S) 和 H(S) 为一组围栏 S 的图和对偶图.  
和以前一样, 当我们枚举 H 中的顶点和面的时候, 将外层无限空间当作一个面.  
在建造工作完成之后, 打印机应该停在 G 中的某个面, 即 H 中的某个点上.  
并且, 我们最后建造的围栏, 在与那个面相邻的边上.  
从后往前思考, 最后的围栏 f 建造之前, 打印机在 G(F - {f}) 的某个面上.  
其中 F 是所有围栏的集合.  
对于任意围栏集合 S 和其中任意围栏 f, G(S) 和 G(S - {f}) 都有很大关系.  
同样地, H(S) 和 H(S - {f}) 也有很大关系.  
G(S - {f}) 是从 G(S) 中去除掉 f, 也去除掉它的端点的结果.  
H(S - {f}) 要么和 H(S) 相同, 要么是合并 H(S) 中的两个顶点的结果,  
因为 f 在 G(S) 中可能有一个或两个相邻的面.  
说回 G(F - {f}), 倒数第二个建造的围栏 g, 它与 f 一定与同一个面相邻.  
往前推也一样.  
构造图 X, 顶点是围栏, 当且仅当两个围栏与同一面相邻, 在他们之间加边.  
建造顺序即是图 X 顶点的一个路径. 路径中前缀的顶点都是相连的.  
DFS 或 BFS 的结果都行.  
现在我们知道如何判定可行的顺序了.  
我们可以贪心法建造符合条件的顺序. 从后往前建造.  
选择 f 作为第一个建造的围栏. 记录每一步能到达的围栏.  
任何可以到达的, 没有被事先规定建造顺序的围栏, 都可以立即建造.  
被事先规定建造顺序的围栏, 可以贪心法加入.  
如果失败, 选择另一个 f.  
构造 G 和 H 需要线性时间, 从 H 构造 X 需要平方时间,  
选择 f 需要线性时间, 贪心法需要常数时间.  
其实可以将效率提升至准线性时间: 不用特意构造 X.  
从 H 直接检查未到达围栏的邻接情况.  
至于确定第一个 f, 事实证明, 将 f 设置为围栏 K,  
即事先规定建造顺序的, 最后一个建造的围栏, 总是可行的.  

  
### 2018_3_3 raise the roof  
人类学家刚刚发现一群古希腊几何学家的秘密: 他们喜欢派对, 就像喜欢数学!  
事实上, 他们每年都举办更大型的派对, 所以每年都要抬高屋顶,  
以将噪音控制在能接受的水平内.  

我们知道屋顶总是由 3 个柱子支撑的. 柱子是细线段, 从地板垂直上升.  
每次他们要抬高屋顶, 会先移除现有屋顶, 然后在没有柱子的地方加一根柱子.  
最后把新屋顶放在新柱子和两根最新的旧柱子上.  
没有 3 根柱子尖端是共线的, 没有 4 根柱子尖端是共面的.  
每个屋顶是一个凸多边形. 在柱子尖端定义的平面上.  
对于之前的每个柱子 c, 屋顶不与 c 相交, 并且能覆盖 c 上方的空间.  

在考古发掘中, 你找到了全部 N 根柱子, 但是没有找到屋顶.  
你想知道一个可能的柱子建造顺序.  
一个可能的顺序满足:  
对于长度 >= 4 的前缀, 能有一个屋顶, 包含最新的 3 根柱子的尖端;  
对于其他尖端在点 (x, y, h) 的柱子, 屋顶包含点 (x, y, z), 其中 z > h.  

#### 2018_3_3 思路  
小数据集:  
柱子数量足够小, 可以用暴力法, 检查最多 10! 个方案.  
对每个方案, 检查方案中所有长度 3 以上的前缀,  
用最后三根柱子建一个平面, 确保前面所有柱子, 都在平面以下.  
因为没有 3 根柱子的尖端是共线的, 所以任意 3 根柱子都确定一个平面.  
记 p1, p2, ..., pk 是前缀中的 k 个柱子尖端的点.  
记 q 为 p(k-2), p(k-1), pk 确定的平面.  
对于任意 1 到 k-3 的 i, 我们需要确定是否 pi 在 q 的上方.  
注意到, 我们可以将 pk 从所有的点中去掉, 结果不会改变.  
我们假定 pk = (0, 0, 0).  
记 v 为平面 q 的法向量.  
将 pi 投影到 v 上, 检查 v 和投影是不是在 q 的同一面.  
如果是, 则 pi 在 q 的上方, 否则不是.  
以下方法可以改进效率:  
产生排列的时候, 一次加一根柱子. 这样前缀相同的不必重复判断.  
或者对子集用动态规划.  

大数据集:  
暴力法肯定不行.  
我们可以试试从后往前. 先找到最后的屋顶, 每次抽掉一根柱子.  
我们首先要找到最后的两根柱子的尖端 p 和 q.  
然后, 定义 s 为除了 p 和 q 的所有的柱子尖端的集合, 重复以下操作:  
1. 找到一个点 r, 使得包含 p, q, r 的平面在所有其他点的上方.  
2. 从集合中去掉 r, p = q, q = r.  
最终找到的集合顺序与答案是相反的.  

要找到 r, 我们只需要试所有可能的点. 这一步需要 O(N^2).  
为了提高效率, 想象最后的屋顶所在的平面, 但目前只被 2 根柱子支撑.  
我们可以转动平面, 以两根柱子的尖端定义的直线为轴, 找到最先碰到的尖端.  
最先碰到的可能有两个. 换句话说, 我们要选择转动角度最小的那个.  
也就是找 p, q, r 定义平面的法向量, 和最后屋顶的法向量夹角最大的那个.  

要找到最初的 p 和 q, 我们可以试试所有的可能.  
p 的柱子一定是最高的柱子. 想象一个经过 p 的平行于地面的平面.  
这个平面一定超过所有其他屋顶.  
接下来找一个 q, 让 p-q 与这个平行于地面的平面角度最小.  
方法与上面所述类似.  

  
### 2018_3_2 name-preserving network  
一个研究机构要建一个数据中心.  
数据中心里, 电脑靠双向链接来协同工作. 一个链接连接两台电脑.  
电脑 c1 和 c2 相连的条件是, 有一条链接路径 l1, l2, ..., lk 连接他们.  
研究机构拜托你设计数据中心的网络, 有以下几个要求:  
1. 网络中要有至少 L 台, 最多 U 台电脑.  
2. 每一台电脑都是 4 个链接的终端, 连接到 4 台不同的其他电脑.  
3. 每一对电脑都必须能够通信.  
4. 每一台电脑都必须有自己的唯一标识, 即使他们的 ID 改了.  
最后一点的意思是, 每一台电脑被分配一个 1~N 的 ID. 每次开机 ID 打乱.  
为了检验你的设计, 研究机构设计了一个程序. 在检验了 1~3 点要求之后,  
返回一个经过如下改动的网络:  
1. ID 被随机打乱.  
2. 每个链接连接的两台电脑, 按 ID 小的在前, ID 大的在后排列.  
3. 列出所有链接, 按字典顺序排列.  
你必须知道 ID 如何变化.  
自动化程序会首先根据函数 f(x) 重新分配 ID, 原 i 的现编号是 f(i).  
对于原有的连接电脑 i 和 j 的链接, 在 f(i) 和 f(j) 之间加上链接.  
你必须严格按照自动化程序的顺序重建网络.  
如果另一个 f' 能得到相同结果, 你就不能知道 ID 如何变化, 方案被拒绝.  
对于 10~100 的 N, 都至少有 1 个方案符合要求.  
你能给出一个符合条件的网络连接方案吗?  

#### 2018_3_2 思路  
问题是, 靠什么标识每个节点呢.  
1. 首先, 一个节点完全由它的拓扑结构来标识.  
2. 存在这样的, 每个节点能够唯一标识的网络, 并且能高效地找到这样的网络.  
3. 我们能够高效地计算出给定网络的标识.  
如果我们有一个标识网络的系统, 剩下的就很简单了:  
找一个正确大小的网络, 计算它的标识, 和打乱之后的网络的标识, 对比即可.  
有很多种可能的标识方式. 介绍两种, 一种在理论上占优, 一种操作上占优.  

第一种:  
将网络转换为无向图, 每个节点的度为 4.  
如果我们拿到图的邻接矩阵, 计算它的 p 次方,  
(i, j) 表示从 i 到 j 有几条长度为 p 的路径.  
如果幸运的话, 对每一个 i, (i, 1), (i, 2), ... 会是唯一的.  
事实上, 在 p=7 时, 多数给定大小的图会产生唯一标识.  
我们构造 N 在 10 到 50 之间的图, 只需要试少数几次.  

第二种:  
单独来说, 每台电脑看起来都是一样的, 出度都为4. 他们的邻居看起来也是.  
但如果我们观察邻居是怎么相互连接的呢?  
如果我们将电脑 X 标识为一个四元组 {Y1, Y2, Y3, Y4}.  
其中 Yi 表示, 这台连接 X 的电脑, 与其他三台中的多少台也是邻居.  
这还不足以标识每台电脑. 我们将上述四元组标识为 level 1 标识.  
我们可以定义 level 2 标识为, 包含 level 1 标识的四元组.  
到 level 4 的时候, 基本能够将电脑区分开了.  

接下来我们来看怎么创建一个网络.  
不能随机加边, 因为要满足每个节点的度为 4 的条件.  

一个简单方法是, 每次将所有节点乱序排列, 然后连接 1-2, 3-4, 进行 4 次.  
如果出现了自循环, 或者有重复链接, 就重来直到不出现.  

另一个办法是, 先构造一个环, 每个节点连接到它的邻居, 和邻居的邻居.  
这样符合度为 4 的条件. 然后:  
1. 随机挑选电脑 A 和它的一个邻居 B.  
2. 随机挑选 A 的一个邻居 C, 和 B 的一个邻居 D, 其中 A-D, B-C 不是邻居.  
3. 移除 A-C, B-D 连接, 加上 A-D, B-C 连接.  
这个方法保证了每个节点总是有 4 个链接, 并且所有节点连通.  
多数网络(在经过比如 1000 次修改之后), 会有每台电脑的唯一标识.  
不对就再试一遍.  

最后注意, 所有大小的图可以事先计算好并且在代码中硬编码.  
只要标识算法足够高效, 那么找图有点慢也是没关系的.  
不过, 上述方法不硬编码也是足够快的.  

  
### 2018_3_1 field trip  
小学里的 N 个人, 1 个老师和 N-1 个学生, 正在野外郊游.  
他们在探索一块无限的二维网格草地.  
每个学生在一个网格上, 一个网格可以站多个学生.  
当他们该回家的时候, 老师和学生必须在同一网格集合.  
老师的编号是 1, 学生的编号是 2 到 N.  
一个 action 是指, 向与当前网格相邻的 8 个网格的其中一个移动.  
当该回家的时候, 老师检查大家是否都在同一网格, 如果不是:  
1. 老师进行一次 action. 老师选择方向.  
2. 每个学生按编号轮流行动, 向缩短与前一个的距离的方向行动.  
以上为一回合. 如果一回合不能完成, 则开始另一回合. 直到完成.  
如果老师按最优选择行动, 最少需要进行多少回合?  

#### 2018_3_1 思路  
小数据集:  
因为学生的数目和草地的大小足够小, 可以贪心法模拟.  
一个观察是, 横向和纵向的情况可以分开考虑.  
每一步, 第 i 个学生总是向第 i-1 个学生前进 1 步.  
另一个观察是, 当我们只考虑横向或纵向时,  
耗时最长的, 总是离老师最远的学生.  
记 K 为, 一个维度, 一个方向上, 最远学生的最小编号.  
所以编号小于 K 的学生, 要么离老师更近, 要么在相反方向上.  
编号 K 的学生向老师走一步, 编号 > K 的学生也会向老师走.  
所以最佳方案是让最远学生的距离最短, 横向和纵向分开考虑.  
即老师应该移动到, 横坐标为横向两个方向最远的两个学生的中点,  
纵坐标为纵向两个方向最远的两个学生的中点.  

大数据集:  
max(横向学生最远距离 / 2, 纵向学生最远距离 / 2)  

  
### 2018_2_4 gridception  
Jom Codd 是一个盗梦大师.  
观察梦境的技术还很不成熟, Codd 看到的梦境是一个由黑白格子组成的网格.  
给定一个起始梦境网格, Codd 可以"深入"这个梦境.  
"深入"的方法是, 将一格替换为 2x2 个同颜色的网格, 即扩展为原来的 4 倍.  
Codd 刚刚入侵了一个梦境, 看到了它的初始梦境网格.  
他知道他必须"深入"这个梦境多次. 为了导航, 他在寻找特定的"花纹".  
一个"花纹"由一组有共同边的网格组成, 加上它们的颜色.  
花纹可以是中空的. 如果有两个花纹, 网格有相同的数量和排列, 则他们相同.  
Codd 想知道起始梦境中是否存在一个花纹, 在"深入" 10^100 次之后的梦境中,  
依然存在.  
输出符合条件的花纹中, 最大的网格数量.  

#### 2018_2_4 思路  
小数据集: 1 <= R <= 3, 1 <= C <= 4  
完全搜索就可以解决. 枚举所有的花纹. 检查它是否存在于深入 2 遍的网格.  
注意深入 1 遍的图案是不够的. 至少每个格子要扩展到 4 x 4, 即深入 2 遍.  
最多有 O(2^(R * C)) 种花纹, 深入需要 O(R x C) 时间.  

大数据集:  
R 和 C 最多可以到 20. 上面的方法太慢.  
我们不能枚举所有可能的花纹了.  
观察到, 每一个可能的花纹会与最多 4 个深入之后的格子重合.  
这意味着, 花纹必须能够分成 4 份, 横一刀, 竖一刀, 每一份颜色相同.  
然后我们考虑所有可能的四分中心 (最多有 2^4 x R x C) 个,  
对于每个四分中心和特定颜色, 找到尽可能多的相连的同颜色的网格.  
找到最大连接分量需要 O(R x C).  

  
### 2018_2_3 costume change  
Supervin 是一个著名的编舞家. 今天是他职业生涯的 N 周年纪念日.  
为了庆祝, 他打算排一个 N x N 的舞蹈队形.  
每个舞蹈演员都有演出服, 每套演出服有一个颜色, 材料是羊毛或棉.  
演出服有 N 种颜色可选. 每个舞蹈演员都想自己是特别的.  
如果同一行或同一列有两个舞蹈演员穿相同颜色和材料的演出服, 就不特别了.  
Supervin 想改一些演出服, 让所有的舞蹈演员都是特别的.  
他最少需要改多少套演出服?  

#### 2018_2_3 思路  
小数据集:  
每个演员试过去太慢. 即使是小数据集.  
这个问题可以转换为,  
找到最大子集, 子集中所有同一行同一列的演员的演出服都不同.  
然后修改不在子集中的演员的演出服.  
所以遍历所有的子集, 找到符合条件的, 最大的子集即可.  

大数据集:  
我们需要一个更有效的找到最大子集的方法.  
定义 f(x) 为穿演出服 x 的演员的最大子集, 他们不在同一行同一列同时出现.  
所以最终的子集是 f(i) 之和, 其中 -N <= i <= N, (i != 0).  
我们怎么找到 f(x) 呢? 我们创造一个二分图:  
1. {Ai} 是一组节点, 表示一行.  
2. {Bi} 是另一组节点, 表示一列.  
3. 当第 i 行和第 j 列有演员穿演出服 x, 为 Ai 和 Bj 加一条边.  
找到二分图的最大匹配.  

  
### 2018_2_2 graceful chainsaw jugglers  
你是一个电锯杂耍团的经理.  
你有无限的天才杂耍者, 每个杂耍者都能耍任何数量的电锯.  
要进行一场表演, 你会选择一些杂耍者, 将你的红色电锯和蓝色电锯分给他们.  
每个人至少分到一个电锯. 一个电锯只能被一个杂耍者使用.  
根据你的市场调研, 你的观众喜欢看到尽可能多的杂耍者和电锯,  
但是不能有两个杂耍者, 使用的红色和蓝色电锯数量都相同.  
你有 R 把红色电锯, 和 B 把蓝色电锯, 你必须把它们全部用上.  
你的演出中最多能有多少杂耍者?  

#### 2018_2_2 思路  
用 (b, r) 对来定义一个杂耍者, 其中, 0 <= r <= R, 0 <= b <= B.  

小数据集:  
把问题转换为, 在 V = [0; B] x [0; R] 的集合中, 找到一个子集,  
使得 b 之和为 B, r 之和为 R.  
小数据集中, V 很小, 可以用动态规划. 类似背包问题.  
定义 f(i, b, r) 为, 只考虑前 i 个 b-r 对, 找出一个数量最多的子集,  
使蓝色之和为 b, 红色之和为 r.  
时间可能要 (B + 1)^2 * (R + 1)^2.  
一个提速的办法是, 对于所有的 case, 同参数的 f 结果相同, 可以记录查表.  

大数据集:  
针对这个问题, 有几点观察.  
定义 br-valid 组为蓝色之和 = b, 红色之和 = r.  
定义 week-br-valid 组为蓝色之和 <= b, 红色之和 <= r.  
week-br-valid 组的一个特点是, 对于特定的 b 和 r, 他的最大元素数量 X,  
等于 br-valid 组的最大元素数量 Y.  
定义 minimal-week-br-valid 组为一个 week-br-valid 组 S.  
S 中的任意 b-r 对 (i, j),  
i > 0 时, (i-1, j) 也在 S 中. 同样的, j > 0 时, (i, j-1) 也在 S 中.  
可以证明, 对特定的 b 和 r, 最大的 minimal-week-br-valid 组的大小,  
等于最大的 week-br-valid 组.  
现在问题转换为, 找到特定 b 和 r 的最大 week-br-valid 组的大小.  
根据最小原则, 如果 (i, j) 在集合里, 那 (i-1, j), (i, j-1) 也在集合里.  
对于给定的 (i, j), 如果它在集合里,  
则红色的和至少为 (j + 1) * (1 + 2 + ... + i) = (j + 1) * i * (i + 1)/2  
同样蓝色的和至少为 (i + 1) * j * (j + 1)/2.  
所以我们可以使用这个 i, j 形成组合 V', 进行动态规划.  

  
### 2018_2_1 Falling Balls  
有一种玩具, 由 1 行以上, 2 列以上的网格组成.  
每格是 \ 斜坡, / 斜坡或空. 最左最右的列为空, 最后一行也为空.  
球从第一行落下, 遇到斜坡改变列, 最终落到最后一行.  
你的朋友有一个这样的玩具, 有 C 列, 行数未知.  
他在第一行的每一列都扔下一颗小球. 记录最后每一列有几颗小球. 给你结果.  
但你觉得结果可能有错.  
你能创造一个与结果一致的, 行数最少的玩具吗? 或者指出这不可能?  

#### 2018_2_1 思路  
如果第一行和最后一行小球的数量为 0, 不可能.  
从左到右安排小球最终落在哪一列.  
构造一个全空的玩具.  
哪个球需要落在哪一列, 就连续放几个斜坡把小球送过去.  
